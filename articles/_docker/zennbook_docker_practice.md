---
layout: article
title: Zenn 『実践 Docker - ソフトウェアエンジニアの「Docker よくわからない」を終わりにする本』を読んだ
permalink: /docs/docker/zennbook_docker_practice
date: 2023-06-30
aside:
  toc: true
tags: ["Docker", "Zenn", "読書感想文", "実践 Docker - ソフトウェアエンジニアの「Docker よくわからない」を終わりにする本"]
---

Dockerの勉強をしたので読書感想文としてまとめておきます。

今回読んだのは、Zennで無料公開されていた本です。
[実践 Docker - ソフトウェアエンジニアの「Docker よくわからない」を終わりにする本](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59)

## 本の概要

この本では、Dockerとは、コンテナとは、というところから始まり、Dockerコマンドの使い方、Dockerfileの書き方を見てから、Webサーバ・データベース・メールサーバという3つのコンテナを組み合わせたアプリケーションの構築をおこなっていきます。
アプリケーション構築を通してボリューム、バインド、ネットワークの使い方を学び、Docker Composeを勉強する、という流れになっています。

## 良かった点

3つのコンテナを使ってアプリケーション構築は丁寧に段階を踏んで解説されていたので理解に役立ちました。

最も良かった点は、なぜDockerを使うのか・Dockerの何が良いのかについてが解説されていた点と、読んでいて疑問に思うことが次の段落で説明されていたり、まとめられていたりして後で別で調べなきゃ、と思うことが少なかったという点です。

この後は前者のなぜDockerを使うのか・Dockerの何が良いのかについて、それとわかりやすかったまとめ部分について一部引用しながらメモしておきます。

## 学んだこと

### Dockerコンテナは仮想サーバではなくただの1プロセスと捉えること

この本では、PID = 1のプロセスを**メインプロセス**、それを起動するコマンドを**メインコマンド**と呼んでいます。
（PID = 1のプロセスはLinuxではinitコマンドと呼ばれているようです。）

[２部: コンテナの状態遷移](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/2-4-container-status)

> たとえばコンテナが仮想サーバではなくただの１プロセスに見えてくると、「Ubuntu に PHP と MySQL と Apache を入れたコンテナを作ろう」ではなく「PHP と MySQL と Apache が必要だから３コンテナ作ろう」という発想に自然と変わります。
> 
> また、メインプロセスが終了したコンテナは自動で停止する という重要な点を理解できるようになります。

```bash
$ docker container run \
    --name nginx3      \
    --rm               \
    --detach           \
    nginx:1.21
```

> 起動した nginx は Web サーバなので、 メインプロセスは止まれと言うまで止まりません。
> メインプロセスは勝手に終了しないので、コンテナは停止か削除をするまで終了しません。

```bash
$ docker container run \
    --name nginx4      \
    --rm               \
    --interactive      \
    --tty              \
    nginx:1.21         \
    bash

# do something

# do something

# exit
```

> 起動した bash は exit できるので、メインプロセスはいつか終了します。
> メインプロセスが終了した場合、コンテナは連動して停止します。

```bash
$ docker container run \
    --name nginx5      \
    --rm               \
    nginx:1.21         \
    ls /etc/nginx
```

> 起動した ls は結果を表示するだけなので、メインプロセスは即時終了します。
> メインプロセスが即終了するので、コンテナも連動して即時停止します。

### Dockerfileをゼロから書くための試行錯誤

Dockerfileをゼロから書くときに試行錯誤をおこなうおすすめの方法について紹介されていました。

[３部: イメージのビルド｜実践 Docker - ソフトウェアエンジニアの「Docker よくわからない」を終わりにする本](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-2-image)

> Dockerfile をゼロから書く場合は、基本的には「ベースイメージをただ起動して bash で試す」「そこで動いたコマンドを Dockerfile にペーストする」というサイクルになるでしょう。

### --volumeオプションよりも--mountオプションを使う

[３部: ボリューム](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-4-volume#--volume-%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8---mount-%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E4%BD%BF%E3%81%84%E5%88%86%E3%81%91)

--volumeオプションと--mountオプションは同じようにコンテナにボリュームをマウントできます。
下の2つの書き方は同じ意味になります。

```
--volume docker-practice-db-volume:/var/lib/mysql
```

```
--mount type=volume,src=docker-practice-db-volume,dst=/var/lib/mysql
```

--volumeオプションのほうが短く書けますが、`:`のルールを知らないとわかりにくいです。

--mountオプションのほうが見やすく、さらにDocker Composeとの互換性があります。下がDocker Composeのyamlファイルの書き方です。

```
volumes:
  - type: volume
    source: docker-practice-db-volume
    target: /var/lib/mysql
```

そのため、Docker公式でも--mountオプションを使うことが推奨されています([Docker Documentation](https://docs.docker.com/storage/bind-mounts/))。

> New users should use the `--mount` syntax.

### バインドマウントでの操作はホストマシンにも影響が出る

[３部: バインドマウント](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-5-bind-mount#%E3%83%90%E3%82%A4%E3%83%B3%E3%83%89%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E5%AE%9F%E4%BD%93%E3%81%A8%E6%B3%A8%E6%84%8F)

バインドマウントしたファイルまたはディレクトリはホストマシンに存在していることに注意が必要です。

> 「仮想環境だから」と安易に`rm -rf *`でもして、もしそこにバインドマウントしたディレクトリが含まれていたら、**削除はホストマシンに波及します**。

まずはボリュームの利用を検討し、それが難しければバインドマウントを使うことが良いと書かれていました。
開発環境でソースコード変更をコンテナにすぐに反映するなどの用途ではバインドマウントのほうが有利でしょう。

### COPYとバインドマウントの使い分け

[３部: バインドマウント](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-5-bind-mount#copy-%E3%81%A8%E3%83%90%E3%82%A4%E3%83%B3%E3%83%89%E3%83%9E%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E4%BD%BF%E3%81%84%E5%88%86%E3%81%91)

`COPY`とバインドマウントはどちらもホストマシンのファイルをコンテナで扱えるようにする機能。
**用途**と**反映タイミング**を理解しておくことで混乱を避けたり、ユースケースごとにうまく使い分けたりできます。

#### 反映タイミング

> `COPY`は`image build`**をするタイミングでイメージにファイルを含める**ため、**コンテナが起動すればファイルが存在**します。
> また**元ファイルの変更を行ってもコンテナには反映されない**ため、`image build`**の再実行が必要**になります。

> バインドマウントは**イメージではなくコンテナに行う**ため、同じイメージを使ってもファイルの存在はコンテナ起動のオプションによって異なります。
> また**ホストマシンでファイルを変更するとコンテナに即時影響します**。

#### 用途

`COPY`

> - 設定ファイルなど、**コンテナによって変えない**かつ**滅多に変更しな**ものを配置する場合
> - 本番デプロイ時のソースコードなど、**即起動できる配布物を作る**場合

バインドマウント

> - 開発時のソースコードなど、**ホストマシンで変更したいがコンテナに随時反映したい**ものがある場合
> - 初期化クエリなど、**イメージを配布する時点では用意できない**ものがある場合

### Dockerネットワークの整理

[３部: ネットワーク](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-7-network)

#### デフォルトで用意されているブリッジネットワークとオーバーレイネットワークの特徴

ブリッジネットワーク

> - ネットワークドライバを特に指定しなかった場合の**デフォルト**である
> - 同一の**Docker Engine上のコンテナ**が互いに通信をする場合に利用する


オーバーレイネットワーク

> - **異なるDocker Engine上のコンテナ**が互いに通信をする場合に利用する

### デフォルトブリッジネットワークと自ら設定したブリッジネットワークの違い

デフォルトブリッジネットワーク

- コンテナを起動する際にネットワークドライバについて一切の指定を行わないと、自動的に生成されてコンテナはこれに接続される
- コンテナが通信するためには、全てのコンテナ間をリンクする操作が必要になる
  - リンクする作業に非常に手間がかかる
- コンテナ間の通信はIPアドレスで行う
- Docker Engine上の全てのコンテナに接続できてしまう
  - 今回作成したコンテナ以外のコンテナ、別目的で作成したコンテナなど

自分で作成したブリッジネットワーク

- 相互通信をできるようにするには同じネットワークを割り当てるだけ
- コンテナ間で自動的にDNSで名前解決することができる
- 通信できるコンテナが同一ネットワーク上のコンテナに限られ、隔離度があがる

### Docker Composeが作成するネットワーク

[３部: Docker Compose｜実践 Docker - ソフトウェアエンジニアの「Docker よくわからない」を終わりにする本](https://zenn.dev/suzuki_hoge/books/2022-03-docker-practice-8ae36c33424b59/viewer/3-8-docker-compose)

> Docker Composeでは**自動でブリッジネットワークが作成されます**。
> また**サービス名が自動でコンテナのネットワークにおけるエイリアスとして設定されます**。

つまり、`docker-compose.yml`ではネットワークの指定が不要であり、コンテナ間のDNS名前解決に使われる名前としてサービス名を使うことができます。
